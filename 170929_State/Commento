Il thread inizializzati accedono allo stato new , al richiamo del metodo .start(); si sposta nello stato READY
alla quale la schedular decide di prendere il thread (prende prima quelli in base alla convenienienza) e di spostarlo nello stato RUNNING
Il nostro thread durante lo stato RUNNING puo accedere a tre stati diversi "WAITING" "TIMED WAITING" E "BLOCKED"
col metodo td.join(); il nostro thread va in attesa fino a quando il Thread td non va nello stato TERMINATED (ovvero ha finito il metodo run(); o é stato stoppato)
per stampare lo stado del metodo in attesa bloccato nel metodo join , non ho fatto altro che creare una classe osservatore che implementa un'interfaccia :
Osservatore che permette di accedere a metodi che concedono di modificare l'oggetto da osservare e metodi che permettono di stampare l'aggiornamento;
Mentre l'intefaccia Osserato che va data alla classe che viene osservato che permette di impostare da chi farsi osservare, o notificare l'eventuale aggiornamento.

Prima del td.join(); Creo il Thread osservatore : Thread osservato = new Thread(new Osserva(Thread.currentThread()),"TD");
lo metto Ready cosi lo scheduler lo runna  osservato.start(); 
e infine chiamo il metodo join();

Quindi il nostro thread osservatore non fa altro che stampare lo stato del thread che gli abbiamo passato come parametro (che é andato nello stato WAITING in quanto ha chiamato join();)
dopo il join mi chiedo se il Thread torna RUNNABLE o prima va in un altro stato , quindi aggiungo le seguenti righe di codice : 

                
            // Sto nel while fino a quando il thread che era in WAITING non va in BLOCKED
            // Se la mia teoria fosse sbagliata non uscirebbe mai dal while
            while(daOsservare.getState()!=Thread.State.BLOCKED){
            }
            // E invece esce e stampa subito RUNNABLE quindi prima di passara a RUNNABLE
            // c'é un istante in cui é BLOCKED.
            aggiorna();


                /*
                /////////////IPOTESI MIA////////////////
                Sono piuttosto convinto del fatto che un Thread prima di tornare RUNNABLE
                debba spostarsi in uno stato chiamato "BLOCKED" nella quale il thread é inattivo,
                e ci va se e solo se sta provando ad accedere ad una risorsa (Object) che é
                gia utilizzata da un altro Thread , che quindi attenderemo che torni disponibile
                , tutte queste decisioni sono ovviamente prese dalla scheduler...
                */

Reso conto: un thread durante l'attesa del metodo join(); ossia un'attesa non definita dal tempo in quanto stiamo aspettando che un altro thread finisca o venga stoppato (entrando nello Stato TERMINATED)
	   é nello stato WAITING....
	Dopo lo stato WAITING per una frazzione di attimo va nello stato BLOCKED nella quale la scheduler si chiede se la risorsa che il Thread occupera é gia occupata da un altro Thread , se no
	il thread va RUNNABLE , altrimenti il thread sta BLOCKED fino a quando la scheduler non rileva la risorsa libera di nuovo ... nello stato BLOCKED il thread é inattivo e non consuma neanche
	un ciclo della CPU.

Sabani Florian.
