Il thread inizializzati accedono allo stato NEW, al richiamo del metodo .start();
alla quale la schedular decide di prendere il thread (prende prima quelli in base alla convenienienza) e di spostarlo nello stato RUNNING
Il nostro thread durante lo stato RUNNING puo accedere a tre stati diversi "WAITING" "TIMED WAITING" E "BLOCKED"
col metodo td.join(); il nostro thread va in attesa fino a quando il Thread td non va nello stato TERMINATED (ovvero ha finito il metodo run(); o é stato stoppato)
per stampare lo stado del metodo in attesa bloccato nel metodo join(); , non ho fatto altro che creare una classe osservatore che implementa un'interfaccia :
Osservatore che permette di accedere a metodi che concedono di accedere ad informazioni delll'oggetto da osservare e metodi che permettono di stampare l'aggiornamento;
Mentre l'intefaccia Osserato che va data alla classe che viene osservato che permette di impostare da chi farsi osservare, o notificare l'eventuale aggiornamento.

Purtroppo affidare queste interfaccie ai Thread ha poco senso in quanto ....

Per stampare il cambiamento dello stato di un thread , il thread stesso che sarebbe L'OSSERVATO non puo mandare la notifica agli OSSERVATORI in quanto lui non puo sapere che cambierebbe lo stato in WAITING ne prima del join(); manco meno dopo , in quanto lo stato WAITING causato dal metodo join(); non é TIMED_WAITING quindi non si sa il tempo in cui il thread starà in attesa....

Di conseguenza il cambiamento di stato del Thread lo vedrà un Thread OSSERVATORE e non sarà il Thread OSSERVATO a dire agli OSSERVATORI che ha cambiato lo stato.
Più osservatori possono osservare i cambiamenti di un Thread.

Reso conto: un thread durante l'attesa del metodo join(); ossia un'attesa non definita dal tempo in quanto stiamo aspettando che un altro thread finisca o venga stoppato (entrando nello Stato TERMINATED) é nello stato WAITING....


Per notificare il cambiamento dello Stato di un Thread ho fatto cosi:

        aggiorna();//NEW 
        
        while (!daOsservare.getState().name().equals("TERMINATED")) {		// Fino a quando lo stato non e TERMINATED sto nel while
            String statoPrecedente = daOsservare.getState().name();
            while (statoPrecedente.equals(daOsservare.getState().name())) {
            }
            aggiorna(); // CAMBIAMENTO STATO
        }
        
        aggiorna(); // TERMINATED

Discorso dello stato BLOCKED :

	Dopo lo stato WAITING per una frazzione di attimo va nello stato BLOCKED nella quale la scheduler si chiede se la risorsa che il Thread occupera é gia occupata da un altro Thread , se no
	il thread va RUNNABLE , altrimenti il thread sta BLOCKED fino a quando la scheduler non rileva la risorsa libera di nuovo ... nello stato BLOCKED il thread é inattivo e non consuma neanche
	un ciclo della CPU.

Differenza tra WAITING e BLOCKED :
	Lunica differenza é che sostanzialmente nello Stato BLOCKED stiamo aspettando che una risorsa si liberi per poterci accedere , quindi siamo in attesa, nel WAITING , stiamo in attesa anche li , ma la risorsa che é occupata non c'é...
                
Per vedere se lo stato BLOCKED é rilevabile:

            // Sto nel while fino a quando il thread che era in WAITING non va in BLOCKED
            // Se la mia teoria fosse sbagliata non uscirebbe mai dal while
            while(daOsservare.getState()!=Thread.State.BLOCKED){
            }
            // E invece esce e stampa subito RUNNABLE quindi prima di passara a RUNNABLE
            // c'é un istante in cui é BLOCKED.
            aggiorna();


Sabani Florian.
